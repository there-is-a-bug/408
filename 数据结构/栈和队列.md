# 栈(Stack)

在一端进行插入和删除操作的线性表——**后进先出(LIFO)**

## 操作

InitStack(&S)

DestroyStack(&S)

Push(&S,x)  —— Pop(&S,&x)

GetTop(S,&x)：读取不删除

StackEmpty(S)

**n个不同元素进栈，出栈元素不同排列个数为 卡特兰数(Catalan)：**
$$
\frac{1}{n+1}C^n_{2n}
$$

## 实现

### 顺序栈——顺序存储

```c
typedef strcut
{
    Elemtype data[MaxSize];
    int top;// top指针
}SqStack;
```

共享栈

### 链栈——链式存储

单链表

# 队列

一端进入，一端删除——先进先出(FIFO)

## 操作

InitQueue(&Q)

DestroyQueue(&Q)

EnQueue(&Q,x) : input

DeQueue(&Q,x) : output

## 实现

### 顺序队列——顺序存储

```c
typedef struct
{
    ElemType data[MaxSize];
    int front,rear; //头尾指针
}SqQueue;
```

判断队列存满：

因为先进先出的缘故——front和rear必须相等才表示存满，因为在出队时，头指针front会移动，也就是不会指向data[0]，那么头指针之前的空间就是空闲的。**用循环队列**

### 队列链——连式存储

## 双端队列

两端插入，两端删除；

受限：输入受限（一端输入，两端删除），输出受限（一端删除，两端输入）

输出序列合法性

# 应用

## 栈

### 括号匹配问题——语法分析

利用后进先出，解决括号匹配问题

### 表达式求值

中缀，前缀，后缀表达式——根据运算符的位置，

中： a + b ，前：+a b ，后：a b+

中缀表达式的求值——转成后缀

### 内存栈

## 队列

树的层次遍历 

图的广优先遍历

操作系统中.....

# 特殊矩阵的压缩存储



